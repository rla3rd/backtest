import datetime
import numpy as np
import pandas as pd
import Queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the 
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are 
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object. 
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                        self.events.put(signal)
                        self.bought[s] = True

class BuyOnDipStrategy(Strategy):
    """
    This is a strategy that buys on a dip and sells on rebound.
    Best use is primarily ETFs where trying to best catch short-term market fluctionations.
    """
    def __init__(self, bars, events):
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """ 
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        create signal events
        in asof, ticker, exchange, signal format
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N = 201)
                df = pd.DataFrame(bars, columns = self.bars.bar_columns)
                df['closepctchg'] = df['adjclose'].pct_change(periods=1)
                df['lowpctchg'] = df['low'].pct_change(periods=1)
                df['highpctchg'] = df['high'].pct_change(periods=1)
                df['logreturn'] = np.log(df['adjclose'].pct_change(periods=1)+1)
                df['ma200'] = pd.rolling_mean(df['adjclose'], 200)
                df['ma5'] = pd.rolling_mean(df['adjclose'], 5)
                df['lowpctsign'] = np.sign(df['lowpctchg'])
                df['highpctsign'] = np.sign(df['highpctchg'])
                df['closepctsign'] = np.sign(df['closepctchg'])
                df['sumlowsign'] = pd.rolling_sum(df['lowpctsign'], 3)
                df['sumhighsign'] = pd.rolling_sum(df['highpctsign'], 3)
                df['sumclosesign'] = pd.rolling_sum(df['closepctsign'], 3)
                cv = df.tail(1)
                #print bars[0][0], bars[0][1], bars[0][2], cv['ma200'], cv['adjclose'], cv['lowpctsign'], cv['highpctsign'], cv['closepctsign']
                if bars is not None and len(bars) == 201 and cv['ma200'] < cv['adjclose'] and cv['sumclosesign'] == -3 and cv['closepctchg'] < -0.015:
                    if self.bought[s] == False:
                        print 'SIGNAL: ', bars[-1][0], bars[-1][1], bars[-1][2], bars[-1][7], 'LONG'
                        signal = SignalEvent(bars[-1][1], bars[-1][2], bars[-1][0], bars[-1][7], 'LONG')
                        self.events.put(signal)
                        self.bought[s] = True

                if self.bought[s] == True and cv['adjclose'] > cv['ma5']:
                        print 'SIGNAL: ', bars[-1][0], bars[-1][1], bars[-1][2], bars[-1][7], 'EXIT'
                        signal = SignalEvent(bars[-1][1], bars[-1][2], bars[-1][0], bars[-1][7], 'EXIT')
                        self.events.put(signal)
                        self.bought[s] = False
